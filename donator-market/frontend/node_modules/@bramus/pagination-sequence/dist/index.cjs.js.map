{
  "version": 3,
  "sources": ["../src/index.js", "../node_modules/@bramus/range/src/index.js"],
  "sourcesContent": ["import { range } from '@bramus/range';\n\n/**\n * Generate a sequence of numbers for use in a pagination system, the clever way.\n * @author Bramus Van Damme <bramus@bram.us>\n *\n * The algorithm always returns the same amount of items in the sequence,\n * independent of the position of the current page.\n *\n * Example rows generated:\n * (adjusted to indicate the current page between [] + leading 0s added)\n *\n * [01]-02-03-04-05-06-07-08-..-73-74\n * 01-[02]-03-04-05-06-07-08-..-73-74\n * 01-02-[03]-04-05-06-07-08-..-73-74\n * 01-02-03-[04]-05-06-07-08-..-73-74\n * 01-02-03-04-[05]-06-07-08-..-73-74\n * 01-02-03-04-05-[06]-07-08-..-73-74\n * 01-02-..-05-06-[07]-08-09-..-73-74\n * 01-02-..-06-07-[08]-09-10-..-73-74\n * 01-02-..-07-08-[09]-10-11-..-73-74\n * ...\n * 01-02-..-65-66-[67]-68-69-..-73-74\n * 01-02-..-66-67-[68]-69-70-..-73-74\n * 01-02-..-67-68-[69]-70-71-72-73-74\n * 01-02-..-67-68-69-[70]-71-72-73-74\n * 01-02-..-67-68-69-70-[71]-72-73-74\n * 01-02-..-67-68-69-70-71-[72]-73-74\n * 01-02-..-67-68-69-70-71-72-[73]-74\n * 01-02-..-67-68-69-70-71-72-73-[74]\n *\n */\nconst generate = (curPage, numPages, numPagesAtEdges = 2, numPagesAroundCurrent = 2, glue = '\u2026') => {\n\n    // Define the number of items we would generate in a normal scenario\n    // (viz. lots of pages, current page in the middle):\n    //\n    // numItemsInSequence = the current page + the number of items surrounding\n    // the current page (left and right) + the number of items at the edges\n    // of the generated sequence (left and right) + the glue in between the\n    // different parts generated\n    //\n    // The goal is to enforce all sequences generated to have this amount\n    // of items. By default this magic number would be 11, as seen/counted\n    // in this sequence: 1-02-..-11-12-[13]-14-15-..-88-74\n    const numItemsInSequence = 1 + (numPagesAroundCurrent * 2) + (numPagesAtEdges * 2) + 2;\n\n    // curPage cannot be greater than numPages.\n    const reworkedCurPage = Math.min(curPage, numPages);\n\n    // The value we're about to return$\n    let finalSequence = [];\n\n    // If we have less than numItemsInSequence pages in total, there is no need to\n    // start calculating but just return the full sequence, starting at 1\n    if (numPages <= numItemsInSequence) {\n        finalSequence = range(1, numPages);\n    }\n\n    // We have more pages than numItemsInSequence, start calculating\n    else {\n\n        // If we have no forced amount of items on the edges, then the\n        // sequence must start from the current page number instead of 1\n        const start = (numPagesAtEdges > 0) ? 1 : reworkedCurPage;\n\n        // Parts of the sequence we'll be generating\n        const sequence = {\n            leftEdge: null,\n            glueLeftCenter: null,\n            centerPiece: null,\n            glueCenterRight: null,\n            rightEdge: null,\n        };\n\n        // If the current page is nearby the left edge (viz. curPage is\n        // less than half of numItemsInSequence away from left edge):\n        // Don't generate a Center Piece, but extend the left part as\n        // the left part would otherwise overlap the center piece.\n        if (reworkedCurPage < (numItemsInSequence/2)) {\n            sequence.leftEdge = range(1, Math.ceil(numItemsInSequence/2) + numPagesAroundCurrent);\n            sequence.centerPiece = [glue];\n            if (numPagesAtEdges > 0) sequence.rightEdge = range(numPages-(numPagesAtEdges-1), numPages);\n        }\n\n        // If the current page is nearby the right edge (viz. curPage is\n        // less than half of numItemsInSequence away from right edge):\n        // Don't generate a center piece but extend the right part as\n        // the right part would otherwise overlap the center piece.\n        else if (reworkedCurPage > numPages - (numItemsInSequence/2)) {\n            if (numPagesAtEdges > 0) sequence.leftEdge = range(start, numPagesAtEdges);\n            sequence.centerPiece = [glue];\n            sequence.rightEdge = range(Math.min(numPages - Math.floor(numItemsInSequence/2) - numPagesAroundCurrent, reworkedCurPage - numPagesAroundCurrent), numPages);\n        }\n\n        // The current page falls somewhere in the middle:\n        // Generate ranges normally\n        else {\n\n            // Center Piece\n            sequence.centerPiece = range(reworkedCurPage - numPagesAroundCurrent, reworkedCurPage + numPagesAroundCurrent);\n\n            // Left/Right Edges (only if we requested)\n            if (numPagesAtEdges > 0) sequence.leftEdge = range(start,numPagesAtEdges);\n            if (numPagesAtEdges > 0) sequence.rightEdge = range(numPages-(numPagesAtEdges-1), numPages);\n\n            // The glue we'll use to stick left, center, and right together\n            // Special case: If the gap between left and center is only one\n            // unit, don't add '...' but add that number instead\n            sequence.glueLeftCenter = (sequence.centerPiece[0] == (numPagesAtEdges+2)) ? [numPagesAtEdges+1] : [glue];\n            sequence.glueCenterRight = [glue];\n\n        }\n\n        // Join all (non-empty) parts of sequence into the final sequence\n        finalSequence = Object.values(sequence).filter(v => v !== null).flat();\n\n    }\n\n    return finalSequence;\n};\n\nconst generateFromObj = (opts = {}) => {\n    const {\n        curPage = 1,\n        numPages = 1,\n        numPagesAtEdges = 2,\n        numPagesAroundCurrent = 2,\n        glue = '\u2026',\n    } = opts;\n\n    return generate(curPage, numPages, numPagesAtEdges, numPagesAroundCurrent, glue);\n}\n\nexport { generate, generateFromObj };\n", "const range = (start, end, step = 1) => {\n    if (!Number.isInteger(start)) {\n        throw new TypeError('start should be an integer');\n    }\n    if (!Number.isInteger(end)) {\n        throw new TypeError('end should be an integer');\n    }\n    if (!Number.isInteger(step)) {\n        throw new TypeError('step should be an integer');\n    }\n\n    if (end < start) {\n        throw new RangeError('end should be greater than start');\n    }\n    if (step < 1) {\n        throw new RangeError('step should be a positive integer');\n    }\n\n    return Array.from({ length: (end - start) / step + 1 }, (_, i) => start + i * step);\n};\n\nexport { range };\n"],
  "mappings": "8gBAAA,qDCAA,GAAM,GAAQ,CAAC,EAAO,EAAK,EAAO,IAAM,CACpC,GAAI,CAAC,OAAO,UAAU,GAClB,KAAM,IAAI,WAAU,8BAExB,GAAI,CAAC,OAAO,UAAU,GAClB,KAAM,IAAI,WAAU,4BAExB,GAAI,CAAC,OAAO,UAAU,GAClB,KAAM,IAAI,WAAU,6BAGxB,GAAI,EAAM,EACN,KAAM,IAAI,YAAW,oCAEzB,GAAI,EAAO,EACP,KAAM,IAAI,YAAW,qCAGzB,MAAO,OAAM,KAAK,CAAE,OAAS,GAAM,GAAS,EAAO,GAAK,CAAC,EAAG,IAAM,EAAQ,EAAI,IDclF,GAAM,GAAW,CAAC,EAAS,EAAU,EAAkB,EAAG,EAAwB,EAAG,EAAO,WAAQ,CAahG,GAAM,GAAqB,EAAK,EAAwB,EAAM,EAAkB,EAAK,EAG/E,EAAkB,KAAK,IAAI,EAAS,GAGtC,EAAgB,GAIpB,GAAI,GAAY,EACZ,EAAgB,EAAM,EAAG,OAIxB,CAID,GAAM,GAAS,EAAkB,EAAK,EAAI,EAGpC,EAAW,CACb,SAAU,KACV,eAAgB,KAChB,YAAa,KACb,gBAAiB,KACjB,UAAW,MAOf,AAAI,EAAmB,EAAmB,EACtC,GAAS,SAAW,EAAM,EAAG,KAAK,KAAK,EAAmB,GAAK,GAC/D,EAAS,YAAc,CAAC,GACpB,EAAkB,GAAG,GAAS,UAAY,EAAM,EAAU,GAAgB,GAAI,KAOjF,AAAI,EAAkB,EAAY,EAAmB,EAClD,GAAkB,GAAG,GAAS,SAAW,EAAM,EAAO,IAC1D,EAAS,YAAc,CAAC,GACxB,EAAS,UAAY,EAAM,KAAK,IAAI,EAAW,KAAK,MAAM,EAAmB,GAAK,EAAuB,EAAkB,GAAwB,IAQnJ,GAAS,YAAc,EAAM,EAAkB,EAAuB,EAAkB,GAGpF,EAAkB,GAAG,GAAS,SAAW,EAAM,EAAM,IACrD,EAAkB,GAAG,GAAS,UAAY,EAAM,EAAU,GAAgB,GAAI,IAKlF,EAAS,eAAkB,EAAS,YAAY,IAAO,EAAgB,EAAM,CAAC,EAAgB,GAAK,CAAC,GACpG,EAAS,gBAAkB,CAAC,IAKhC,EAAgB,OAAO,OAAO,GAAU,OAAO,GAAK,IAAM,MAAM,OAIpE,MAAO,IAGL,EAAkB,CAAC,EAAO,KAAO,CACnC,GAAM,CACF,UAAU,EACV,WAAW,EACX,kBAAkB,EAClB,wBAAwB,EACxB,OAAO,UACP,EAEJ,MAAO,GAAS,EAAS,EAAU,EAAiB,EAAuB",
  "names": []
}
